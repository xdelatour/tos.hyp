<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- last modified on 05.06.2023 -->
<html lang="de">
<head>
<title>
Die Anleitung zum TOS: PCI-BIOS
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="de">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO Version 7.12 (1248) for Linux">
</head>
<body style="position: relative;">

<a name="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_HEAD" href="xbios_main.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24">XBIOS</a>
<a name="UDO_nav_lf_HEAD" href="xbios_overscan.html"><img src="udo_lf.gif" alt="OverScan-XBIOS-Erweiterungen" title="OverScan-XBIOS-Erweiterungen" border="0" width="24" height="24">OverScan-XBIOS-Erweiterungen</a>
<a name="UDO_nav_rg_HEAD" href="xbios_interface.html"><img src="udo_rg.gif" alt="Schnittstellenprogrammierung" title="Schnittstellenprogrammierung" border="0" width="24" height="24">Schnittstellenprogrammierung</a>

<hr>

<h1><a name="PCI-BIOS">4.16 PCI-BIOS</a></h1>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#fast_read_config_byte">fast_read_config_byte</a></td>
<td valign="top"> Read configuration byte fast
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#fast_read_config_longword">fast_read_config_longword</a></td>
<td valign="top"> Read configuration longword fast
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#fast_read_config_word">fast_read_config_word</a></td>
<td valign="top"> Read configuration word fast
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#find_pci_classcode">find_pci_classcode</a></td>
<td valign="top"> Find PCI class code
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#find_pci_device">find_pci_device</a></td>
<td valign="top"> Find PCI device
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#get_machine_id">get_machine_id</a></td>
<td valign="top"> Get machine ID
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#get_resource">get_resource</a></td>
<td valign="top"> Get resource Data
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#get_routing">get_routing</a></td>
<td valign="top"> Get interrupt routing options
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#hook_interrupt">hook_interrupt</a></td>
<td valign="top"> Hook interrupt vector
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#read_config_byte">read_config_byte</a></td>
<td valign="top"> Read configuration byte
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#read_config_longword">read_config_longword</a></td>
<td valign="top"> Read configuration longword
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#read_config_word">read_config_word</a></td>
<td valign="top"> Read configuration word
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#set_interrupt">set_interrupt</a></td>
<td valign="top"> Set hardware interrupt
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#special_cycle">special_cycle</a></td>
<td valign="top"> Generates special cycle
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#unhook_interrupt">unhook_interrupt</a></td>
<td valign="top"> Unhook interrupt vector
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#write_config_byte">write_config_byte</a></td>
<td valign="top"> Write configuration byte
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#write_config_longword">write_config_longword</a></td>
<td valign="top"> Write configuration longword
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#write_config_word">write_config_word</a></td>
<td valign="top"> Write configuration word

</td></tr>
</table>

<p>Querverweis: <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a> &nbsp; <a href="bios_cookiejar.html#Cookie_2C_20_PCI">Cookie _PCI</a> &nbsp; <a href="bios_cookiejar.html#Cookie_2C_20XPCI">Cookie XPCI</a>
</p>
<h3><a name="fast_read_config_byte">4.16.1 fast_read_config_byte</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read configuration byte fast«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 305
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int8_t fast_read_config_byte (int32_t handle, uint8_t reg);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Diese Funktion erlaubt das Lesen von Registern im
Konfigurationsbereich ohne aufwendige Fehler- und
Plausibilitätschecks und ist daher auch etwas schneller als ihre
Schwester (daher besonders geeignet für Interrupt-Routinen und wenn
man ganz genau weiß, was man tut ;-).
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Geräte-Handle des gewählten PCI-Gerätes
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">reg</td>
<td valign="top"> Adresse des Konfigurationsregisters
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a> Fehlercode
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20fast_read_config_byte">Binding</a> &nbsp; <a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#read_config_word">read_config_word</a> &nbsp;
<a href="#fast_read_config_word">fast_read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a> &nbsp;
<a href="#fast_read_config_longword">fast_read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20fast_read_config_byte">4.16.1.1 Bindings für fast_read_config_byte</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int8_t <a href="#fast_read_config_byte">fast_read_config_byte</a> (int32_t handle, uint8_t reg);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #305,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #8,sp         ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="fast_read_config_longword">4.16.2 fast_read_config_longword</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read configuration longword fast«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 307
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t fast_read_config_longword (int32_t handle, uint8_t
reg);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Diese Funktion erlaubt das Lesen von Registern im
Konfigurationsbereich ohne aufwendige Fehler- und
Plausibilitätschecks und ist daher auch etwas schneller als ihre
Schwester (daher besonders geeignet für Interrupt-Routinen und wenn
man ganz genau weiß, was man tut ;-).
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Geräte-Handle des gewählten PCI-Gerätes
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">reg</td>
<td valign="top"> Adresse des Konfigurationsregisters (0,4,8,... für
Langwort-Zugriffe)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a> Fehlercode
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20fast_read_config_longword">Binding</a> &nbsp; <a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#fast_read_config_byte">fast_read_config_byte</a> &nbsp;
<a href="#read_config_word">read_config_word</a> &nbsp; <a href="#fast_read_config_word">fast_read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20fast_read_config_longword">4.16.2.1 Bindings für fast_read_config_longword</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#fast_read_config_longword">fast_read_config_longword</a> (int32_t handle, uint8_t reg);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #307,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #8,sp         ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="fast_read_config_word">4.16.3 fast_read_config_word</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read configuration word fast«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 306
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t fast_read_config_word (int32_t handle, uint8_t reg);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Diese Funktion erlaubt das Lesen von Registern im
Konfigurationsbereich ohne aufwendige Fehler- und
Plausibilitätschecks und ist daher auch etwas schneller als ihre
Schwester (daher besonders geeignet für Interrupt-Routinen und wenn
man ganz genau weiß, was man tut ;-).
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Geräte-Handle des gewählten PCI-Gerätes
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">reg</td>
<td valign="top"> Adresse des Konfigurationsregisters (0,2,4,... für
Wort-Zugriffe)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a> Fehlercode
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20fast_read_config_word">Binding</a> &nbsp; <a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#fast_read_config_byte">fast_read_config_byte</a> &nbsp;
<a href="#read_config_word">read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a> &nbsp; <a href="#fast_read_config_longword">fast_read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20fast_read_config_word">4.16.3.1 Bindings für fast_read_config_word</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#fast_read_config_word">fast_read_config_word</a> (int32_t handle, uint8_t reg);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #306,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #8,sp         ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="find_pci_classcode">4.16.4 find_pci_classcode</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »find_pci_classcode« - Liefert ein Devicehandle für ein
Gerät einer bestimmten Geräteklasse.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 301
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t find_pci_classcode( int32_t classcode, int16_t index );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion liefert ein Devicehandle für ein Gerät, das dem
angegebenen Gerät entspricht.
<br>&nbsp;
<br>Der Treiber kann diese Funktion mehrmals für eine Geräte ID
aufrufen und den index = 0,1,2,... für jeden Aufruf hochzählen, bis
die Funktion <a href="PCI_BIOS.html#PCI_DEVICE_NOT_FOUND">PCI_DEVICE_NOT_FOUND</a> liefert.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">classcode</td>
<td valign="top"> Class code in Bits 23..0
<br>
<br>&nbsp;
<br>Bit 23 ..16 Base class (0 - $FF)
<br>Bit 15 .. 8 Sub class (0 - $FF)
<br>Bit 7 .. 0 Programming Interface (0 - $FF)
<br>&nbsp;
<br>Maske in Bits 26..24
<br>Bit 26: (0: base class testen, 1: ignorieren)
<br>Bit 25: (0: sub class testen, 1: ignorieren)
<br>Bit 24: (0: Progr. Interface testen, 1: ignorieren)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">index</td>
<td valign="top"> Kartenindex (0 - Anzahl Karten mit diesen IDs)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Devicehandle für das Gerät oder <a href="PCI_BIOS.html#PCI_DEVICE_NOT_FOUND">PCI_DEVICE_NOT_FOUND</a>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20find_pci_classcode">Binding</a> &nbsp; <a href="#find_pci_device">find_pci_device</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20find_pci_classcode">4.16.4.1 Bindings für find_pci_classcode</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#find_pci_classcode">find_pci_classcode</a>( int32_t classcode, int16_t index );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    index,-(sp)       ; Offset 6
move.l    classcode,-(sp)   ; Offset 2
move.w    #301,-(sp)        ; Offset 0
trap      #14               ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #8,sp             ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="find_pci_device">4.16.5 find_pci_device</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »find_pci_device« - Liefert ein Devicehandle für ein Gerät,
das dem angegebenen Gerät und der Hersteller ID entspricht.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 300
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t find_pci_device( int32_t id, int16_t index);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion liefert ein Devicehandle für ein Gerät, das dem
angegebenen Gerät und der Hersteller ID entspricht. Der Treiber kann
diese Funktion mehrmals für eine Geräte und Hersteller ID aufrufen
und den index = 0,1,2,... für jeden Aufruf hochzählen, bis die
Funktion <a href="PCI_BIOS.html#PCI_DEVICE_NOT_FOUND">PCI_DEVICE_NOT_FOUND</a> liefert.
<br>&nbsp;
<br>Als Spezialfall kann die Hersteller ID $FFFF benutzt weren, um
alle Geräte abzufragen. Die Geräte ID wird in diesem Fall ignoriert.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">id</td>
<td valign="top"> Geräte ID in Bits 31..16 (0 - $FFFF)
<br>Hersteller ID in Bits 15..0 (0 - $FFFE)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">index</td>
<td valign="top"> Kartenindex (0 - Anzahl Karten mit diesen IDs)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Devicehandle für das Gerät oder <a href="PCI_BIOS.html#PCI_DEVICE_NOT_FOUND">PCI_DEVICE_NOT_FOUND</a>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20find_pci_device">Binding</a> &nbsp; <a href="#find_pci_classcode">find_pci_classcode</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20find_pci_device">4.16.5.1 Bindings für find_pci_device</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#find_pci_device">find_pci_device</a>( int32_t id, int16_t index);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    index,-(sp)  ; Offset 6
move.l    id,-(sp)     ; Offset 2
move.w    #300,-(sp)   ; Offset 0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #8,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="get_machine_id">4.16.6 get_machine_id</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Get Machine ID«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 337
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t get_machine_id ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function can be used to get a unique machine ID for the
computer the driver is running on.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Machine ID oder 0 (keine ID verfügbar) oder <a href="#PCI-BIOS">PCI-BIOS</a>
Fehlercodes
<br>&nbsp;
<br>Positive, non-zero values are machine IDs. They contain a
manufacturer code in bit 24..31 and a unique serial number which is
set by the manufacturer during production in bit 0..23.
<br>&nbsp;
<br>The following manufacturer codes are defined:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">0</td>
  <td align="left" valign="top">Medusa/Hades</td>
</tr>
<tr>
  <td align="left" valign="top">1</td>
  <td align="left" valign="top">Milan</td>
</tr>
<tr>
  <td align="left" valign="top">2</td>
  <td align="left" valign="top">PAK/Panther 2</td>
</tr>
<tr>
  <td align="left" valign="top">3</td>
  <td align="left" valign="top">ARAnyM</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20get_machine_id">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20get_machine_id">4.16.6.1 Bindings für get_machine_id</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#get_machine_id">get_machine_id</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #337,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #2,sp         ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="get_resource">4.16.7 get_resource</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Get Resource Data«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 316
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t get_resource ( int32_t handle );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Liefert sämtliche Infos zu den Resourcen einer PCI-Karte (bzw.
eines PCI-Gerätes im Fall von Multifunktionskarten). Die
zurückgelieferten Infos dürfen von den Geräte-Treibern keinesfalls
verändert werden. Der Geräte-Treiber kann an Hand der angebotenen
Informationen (Byte ordering usw.) die Karte dann direkt ansprechen.
Eine weitere Möglichkeit ist die Verwendung der <a href="bios_main.html">BIOS</a>-Routinen
read_mem_..., write_mem_..., read_io_... und write_io_..., wobei man
sich dann um keinerlei Nebenbedingungen selbst kümmern muß.
<br>Die Routine liefert einen Zeiger auf den ersten Resource
Deskriptor des gewünschten PCI-Gerätes. Der Geräte-Treiber kann
dann die weiteren Deskriptoren über einen Offset (Länge eines
Deskriptors) erreichen. Der letzte Deskriptor des Geräts ist
wiederrum speziell markiert. Die Reihenfolge der Despriptoren
entspricht derer der Basisadreßregister im PCI-Konfigurationsbereich.
Ein PCI-Gerät kann auch mehrere Resourcen des gleichen Typs
anfordern/verwenden.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Geräte-Handle des gewählten PCI-Gerätes
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> positiv - Zeiger auf Resourcen-Informationen (erster
Deskriptor)
<br>negativ - <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20get_resource">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20get_resource">4.16.7.1 Bindings für get_resource</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#get_resource">get_resource</a> ( int32_t handle );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    handle,-(sp)  ; Offset 2
move.w    #316,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #6,sp         ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="get_routing">4.16.8 get_routing</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Get Interrupt Routing Options«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 314
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t get_routing ( int32_t handle );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> To be defined. Not for use by device drivers.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20get_routing">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20get_routing">4.16.8.1 Bindings für get_routing</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#get_routing">get_routing</a> ( int32_t handle );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    handle,-(sp)  ; Offset 2
move.w    #314,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #6,sp         ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="hook_interrupt">4.16.9 hook_interrupt</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Hook Interrupt Vector«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 311
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t hook_interrupt (int32_t handle, uint32_t *routine,
uint32_t *parameter);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function hooks the driver into the interrupt chain to
which a specific interrupt on the given card is routed. The interrupt
is enabled on the system level, however, it is the drivers
responsibility to enable the interrupt on the card as needed.
<br>&nbsp;
<br>The driver should first hook into the interrupt chain, and then
enable the interrupt on the card, in order not to cause spurious
interrupts.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Geräte-Handle des gewählten PCI-Gerätes
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">routine</td>
<td valign="top"> Zeiger auf den Interrupt-Handler des Treibers
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">parameter</td>
<td valign="top"> Zeiger auf Parameter für Interrupt-Handler, dies ist ein vom
Treiber frei zu wählender Wert, der bei jedem Aufruf des Handlers vom
<a href="bios_main.html">BIOS</a> mitübergeben wird.
<br>&nbsp;
<br>Dadurch könnteein einziger Interrupt-Handler auch mehrere
baugleiche PCI-Geräte bedienen.
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20hook_interrupt">Binding</a> &nbsp; <a href="#unhook_interrupt">unhook_interrupt</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20hook_interrupt">4.16.9.1 Bindings für hook_interrupt</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#hook_interrupt">hook_interrupt</a> (int32_t handle, uint32_t *routine,
uint32_t *parameter);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    parameter,-(sp) ; Offset 10
move.l    routine,-(sp)   ; Offset 6
move.l    handle,-(sp)    ; Offset 2
move.w    #311,-(sp)      ; Offset 0
trap      #14             ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       14(sp),sp       ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="read_config_byte">4.16.10 read_config_byte</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read configuration byte«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 302
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t read_config_byte (int32_t handle, uint8_t reg, uint8_t
*address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Dies Funktion erlaubt den Lesezugriffe auf die
Konfigurationsregister eines PCI-Gerätes, dessen Geräte-Handle zuvor
mittels <a href="#find_pci_device">find_pci_device</a> oder <a href="#find_pci_classcode">find_pci_classcode</a> ermittelt wurde.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Geräte-Handle des gewählten PCI-Gerätes
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>reg</i></td>
<td valign="top"> Adresse des Konfigurationsregisters
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>address</i></td>
<td valign="top"> Zeiger auf Ergebnisvariable
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20read_config_byte">Binding</a> &nbsp; <a href="#fast_read_config_byte">fast_read_config_byte</a> &nbsp; <a href="#read_config_word">read_config_word</a> &nbsp;
<a href="#fast_read_config_word">fast_read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a> &nbsp;
<a href="#fast_read_config_longword">fast_read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20read_config_byte">4.16.10.1 Bindings für read_config_byte</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#read_config_byte">read_config_byte</a> (int32_t handle, uint8_t reg, uint8_t
*address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       address       ; Offset 8
move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #302,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       12(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="read_config_longword">4.16.11 read_config_longword</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read configuration longword«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 304
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t read_config_longword (int32_t handle, uint8_t reg,
uint32_t *address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Dies Funktion erlaubt den Lesezugriffe auf die
Konfigurationsregister eines PCI-Gerätes, dessen Geräte-Handle zuvor
mittels <a href="#find_pci_device">find_pci_device</a> oder <a href="#find_pci_classcode">find_pci_classcode</a> ermittelt wurde.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Geräte-Handle des gewählten PCI-Gerätes
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>reg</i></td>
<td valign="top"> Adresse des Konfigurationsregisters (0,4,8,... für
Langwort-Zugriffe)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>address</i></td>
<td valign="top"> Zeiger auf Ergebnisvariable
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20read_config_longword">Binding</a> &nbsp; <a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#fast_read_config_byte">fast_read_config_byte</a> &nbsp;
<a href="#read_config_word">read_config_word</a> &nbsp; <a href="#fast_read_config_word">fast_read_config_word</a> &nbsp; <a href="#fast_read_config_longword">fast_read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20read_config_longword">4.16.11.1 Bindings für read_config_longword</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#read_config_longword">read_config_longword</a> (int32_t handle, uint8_t reg,
uint32_t *address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       address       ; Offset 8
move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #304,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       12(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="read_config_word">4.16.12 read_config_word</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read configuration word«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 303
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t read_config_word (int32_t handle, uint8_t reg, uint16_t
*address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Dies Funktion erlaubt den Lesezugriffe auf die
Konfigurationsregister eines PCI-Gerätes, dessen Geräte-Handle zuvor
mittels <a href="#find_pci_device">find_pci_device</a> oder <a href="#find_pci_classcode">find_pci_classcode</a> ermittelt wurde.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Geräte-Handle des gewählten PCI-Gerätes
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>reg</i></td>
<td valign="top"> Adresse des Konfigurationsregisters
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>address</i></td>
<td valign="top"> Zeiger auf Ergebnisvariable
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20read_config_word">Binding</a> &nbsp; <a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#fast_read_config_byte">fast_read_config_byte</a> &nbsp;
<a href="#fast_read_config_word">fast_read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a> &nbsp;
<a href="#fast_read_config_longword">fast_read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20read_config_word">4.16.12.1 Bindings für read_config_word</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#read_config_word">read_config_word</a> (int32_t handle, uint8_t reg, uint16_t
*address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       address       ; Offset 8
move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #303,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       12(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="set_interrupt">4.16.13 set_interrupt</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Set Hardware Interrupt«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 315
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t set_interrupt ( int32_t handle );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> To be defined. Not for use by device drivers.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20set_interrupt">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20set_interrupt">4.16.13.1 Bindings für set_interrupt</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#set_interrupt">set_interrupt</a> ( int32_t handle );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    handle,-(sp)  ; Offset 2
move.w    #315,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #6,sp         ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="special_cycle">4.16.14 special_cycle</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Generates special cycle«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 313
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t special_cycle ( unit8_t bus, uint32_t data );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function generates a special cycle on the PCI bus.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Bus number
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">data</td>
<td valign="top"> Cspecial cycle data
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20special_cycle">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20special_cycle">4.16.14.1 Bindings für special_cycle</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#special_cycle">special_cycle</a> ( unit8_t bus, uint32_t data );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    data,-(sp)    ; Offset 4
move.w    bus,-(sp)     ; Offset 2
move.w    #313,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #8,sp         ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="unhook_interrupt">4.16.15 unhook_interrupt</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> » «
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 312
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t unhook_interrupt (int32_t handle);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Mit dieser Routine kann man einen mittels <a href="#hook_interrupt">hook_interrupt</a>
angemeldeten Interrupt-Handler wieder entfernen. Der Treiber muß
allerdings beachten, daß die Interrupts auf dem PCI-Gerät schon vor
dem Aufruf dieser <a href="bios_main.html">BIOS</a>-Funktion deaktiviert werden müssen, da es
sonst zu spurious interrupts kommen kann.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Geräte-Handle des gewählten PCI-Gerätes
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20unhook_interrupt">Binding</a> &nbsp; <a href="#hook_interrupt">hook_interrupt</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20unhook_interrupt">4.16.15.1 Bindings für unhook_interrupt</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#unhook_interrupt">unhook_interrupt</a> (int32_t handle);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    handle,-(sp)  ; Offset 2
move.w    #305,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #6,sp         ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="write_config_byte">4.16.16 write_config_byte</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> &lt;Write Configuration Byte&gt;
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 308
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t write_config_byte (int32_t handle, uint8_t reg, uint8_t
val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Dies Routine dient zum Schreiben von Konfigurationsregistern
eines PCI-Gerätes.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Geräte-Handle des gewählten PCI-Gerätes
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>reg</i></td>
<td valign="top"> Adresse des Konfigurationsregisters (0,1,2,... für
Byte-Zugriffe)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>val</i></td>
<td valign="top"> zu schreibender Registerwert
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20write_config_byte">Binding</a> &nbsp; <a href="#write_config_word">write_config_word</a> &nbsp; <a href="#write_config_longword">write_config_longword</a> &nbsp;
<a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#read_config_word">read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20write_config_byte">4.16.16.1 Bindings für write_config_byte</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#write_config_byte">write_config_byte</a> (int32_t handle, uint8_t reg, uint8_t
val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    val,-(sp)     ; Offset 7
move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #308,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       10(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="write_config_longword">4.16.17 write_config_longword</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Write configuration longword«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 310
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t write_config_longword (int32_t handle, uint8_t reg,
uint32_t val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Dies Routine dient zum Schreiben von Konfigurationsregistern
eines PCI-Gerätes.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Geräte-Handle des gewählten PCI-Gerätes
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>reg</i></td>
<td valign="top"> Adresse des Konfigurationsregisters (0,4,8,... für
Langwort-Zugriffe)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>val</i></td>
<td valign="top"> zu schreibender Registerwert
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20write_config_longword">Binding</a> &nbsp; <a href="#write_config_byte">write_config_byte</a> &nbsp; <a href="#write_config_word">write_config_word</a> &nbsp;
<a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#read_config_word">read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20write_config_longword">4.16.17.1 Bindings für write_config_longword</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#write_config_longword">write_config_longword</a> (int32_t handle, uint8_t reg,
uint32_t val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    val,-(sp)     ; Offset 8
move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #310,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       12(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="write_config_word">4.16.18 write_config_word</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Write configuration word«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 309
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t write_config_word (int32_t handle, uint8_t reg,
uint16_t val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Dies Routine dient zum Schreiben von Konfigurationsregistern
eines PCI-Gerätes.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Geräte-Handle des gewählten PCI-Gerätes
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>reg</i></td>
<td valign="top"> Adresse des Konfigurationsregisters (0,2,4,... für
Wort-Zugriffe)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>val</i></td>
<td valign="top"> zu schreibender Registerwert
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20write_config_word">Binding</a> &nbsp; <a href="#write_config_byte">write_config_byte</a> &nbsp; <a href="#write_config_longword">write_config_longword</a> &nbsp;
<a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#read_config_word">read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20write_config_word">4.16.18.1 Bindings für write_config_word</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#write_config_word">write_config_word</a> (int32_t handle, uint8_t reg, uint16_t
val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    val,-(sp)     ; Offset 8
move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #309,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       10(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="PCI-BIOS_20Fehlercodes">4.16.19 PCI-BIOS Fehlercodes</a></h3>
<p>Die folgende Fehlercodes können im Fehlerfall von den
<a href="bios_main.html">BIOS</a>-Routinen zurückgeliefert werden.
</p>
<a name="PCI_SUCCESSFUL"></a>
<a name="PCI_FUNC_NOT_SUPPORTED"></a>
<a name="PCI_BAD_VENDOR_ID"></a>
<a name="PCI_DEVICE_NOT_FOUND"></a>
<a name="PCI_BAD_REGISTER_NUMBER"></a>
<a name="PCI_SET_FAILED"></a>
<a name="PCI_BUFFER_TOO_SMALL"></a>
<a name="PCI_GENERAL_ERROR"></a>
<a name="PCI_BAD_HANDLE"></a>
<div align="left"><table border="1" frame="box" class="UDO_env_table">
<tr>
  <td align="left" valign="top">0x00000000</td>
  <td align="left" valign="top">PCI_SUCCESSFUL</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFFE</td>
  <td align="left" valign="top">PCI_FUNC_NOT_SUPPORTED</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFFD</td>
  <td align="left" valign="top">PCI_BAD_VENDOR_ID</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFFC</td>
  <td align="left" valign="top">PCI_DEVICE_NOT_FOUND</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFFB</td>
  <td align="left" valign="top">PCI_BAD_REGISTER_NUMBER</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFFA</td>
  <td align="left" valign="top">PCI_SET_FAILED</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFF9</td>
  <td align="left" valign="top">PCI_BUFFER_TOO_SMALL</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFF8</td>
  <td align="left" valign="top">PCI_GENERAL_ERROR</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFF7</td>
  <td align="left" valign="top">PCI_BAD_HANDLE</td>
</tr>
</table>
</div>

<p>Die folgenden beiden Fehlercodes werden zwar nicht von den
<a href="bios_main.html">BIOS</a>-Routinen selbst verwendet, sind aber für eine PCI-Library
reserviert.
</p>
<a name="PCI_BIOS_NOT_INSTALLED"></a>
<a name="PCI_BIOS_WRONG_VERSION"></a>
<div align="left"><table border="1" frame="box" class="UDO_env_table">
<tr>
  <td align="left" valign="top">0xFFFFF001</td>
  <td align="left" valign="top">PCI_BIOS_NOT_INSTALLED</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFF000</td>
  <td align="left" valign="top">PCI_BIOS_WRONG_VERSION</td>
</tr>
</table>
</div>

<hr>

<a name="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_FOOT" href="xbios_main.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24">XBIOS</a>
<a name="UDO_nav_lf_FOOT" href="xbios_overscan.html"><img src="udo_lf.gif" alt="OverScan-XBIOS-Erweiterungen" title="OverScan-XBIOS-Erweiterungen" border="0" width="24" height="24">OverScan-XBIOS-Erweiterungen</a>
<a name="UDO_nav_rg_FOOT" href="xbios_interface.html"><img src="udo_rg.gif" alt="Schnittstellenprogrammierung" title="Schnittstellenprogrammierung" border="0" width="24" height="24">Schnittstellenprogrammierung</a>
</body>
</html>
