<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- last modified on 2023/06/05 -->
<html lang="en">
<head>
<title>
The documentation for TOS: PCI-BIOS
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="en">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO Version 7.12 (1248) for Linux">
</head>
<body style="position: relative;">

<a name="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_HEAD" href="xbios_main.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24">XBIOS</a>
<a name="UDO_nav_lf_HEAD" href="xbios_overscan.html"><img src="udo_lf.gif" alt="OverScan XBIOS extension" title="OverScan XBIOS extension" border="0" width="24" height="24">OverScan XBIOS extension</a>
<a name="UDO_nav_rg_HEAD" href="xbios_interface.html"><img src="udo_rg.gif" alt="Interface programming" title="Interface programming" border="0" width="24" height="24">Interface programming</a>

<hr>

<h1><a name="PCI-BIOS">4.16 PCI-BIOS</a></h1>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#fast_read_config_byte">fast_read_config_byte</a></td>
<td valign="top"> Read configuration byte fast
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#fast_read_config_longword">fast_read_config_longword</a></td>
<td valign="top"> Read configuration longword fast
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#fast_read_config_word">fast_read_config_word</a></td>
<td valign="top"> Read configuration word fast
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#find_pci_classcode">find_pci_classcode</a></td>
<td valign="top"> Find PCI class code
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#find_pci_device">find_pci_device</a></td>
<td valign="top"> Find PCI device
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#get_machine_id">get_machine_id</a></td>
<td valign="top"> Get machine ID
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#get_resource">get_resource</a></td>
<td valign="top"> Get resource Data
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#get_routing">get_routing</a></td>
<td valign="top"> Get interrupt routing options
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#hook_interrupt">hook_interrupt</a></td>
<td valign="top"> Hook interrupt vector
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#read_config_byte">read_config_byte</a></td>
<td valign="top"> Read configuration byte
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#read_config_longword">read_config_longword</a></td>
<td valign="top"> Read configuration longword
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#read_config_word">read_config_word</a></td>
<td valign="top"> Read configuration word
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#set_interrupt">set_interrupt</a></td>
<td valign="top"> Set hardware interrupt
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#special_cycle">special_cycle</a></td>
<td valign="top"> Generates special cycle
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#unhook_interrupt">unhook_interrupt</a></td>
<td valign="top"> Unhook interrupt vector
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#write_config_byte">write_config_byte</a></td>
<td valign="top"> Write configuration byte
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#write_config_longword">write_config_longword</a></td>
<td valign="top"> Write configuration longword
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#write_config_word">write_config_word</a></td>
<td valign="top"> Write configuration word

</td></tr>
</table>

<p>See also: <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a> &nbsp; <a href="bios_cookiejar.html#Cookie_2C_20_PCI">Cookie _PCI</a> &nbsp; <a href="bios_cookiejar.html#Cookie_2C_20XPCI">Cookie XPCI</a>
</p>
<h3><a name="fast_read_config_byte">4.16.1 fast_read_config_byte</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read configuration byte fast«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 305
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int8_t fast_read_config_byte (int32_t handle, uint8_t reg);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function reads data from the PCI configuration space of a
given card. It does only minimal error checking and is meant to be
used only when access to configuration space is needed in interrupt
handlers.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">reg</td>
<td valign="top"> Register number (0,1,2,... for byte access)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top">
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS 2.0
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20fast_read_config_byte">Binding</a> &nbsp; <a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#read_config_word">read_config_word</a> &nbsp;
<a href="#fast_read_config_word">fast_read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a> &nbsp;
<a href="#fast_read_config_longword">fast_read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20fast_read_config_byte">4.16.1.1 Bindings for fast_read_config_byte</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int8_t <a href="#fast_read_config_byte">fast_read_config_byte</a> (int32_t handle, uint8_t reg);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #305,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #8,sp         ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="fast_read_config_longword">4.16.2 fast_read_config_longword</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read configuration longword fast«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 307
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t fast_read_config_longword (int32_t handle, uint8_t
reg);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function reads data from the PCI configuration space of a
given card. It does only minimal error checking and is meant to be
used only when access to configuration space is needed in interrupt
handlers.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">reg</td>
<td valign="top"> Register number (0,4,8,... for longword access)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top">
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20fast_read_config_longword">Binding</a> &nbsp; <a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#fast_read_config_byte">fast_read_config_byte</a> &nbsp;
<a href="#read_config_word">read_config_word</a> &nbsp; <a href="#fast_read_config_word">fast_read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20fast_read_config_longword">4.16.2.1 Bindings for fast_read_config_longword</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#fast_read_config_longword">fast_read_config_longword</a> (int32_t handle, uint8_t reg);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #307,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #8,sp         ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="fast_read_config_word">4.16.3 fast_read_config_word</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read configuration word fast«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 306
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t fast_read_config_word (int32_t handle, uint8_t reg);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function reads data from the PCI configuration space of a
given card. It does only minimal error checking and is meant to be
used only when access to configuration space is needed in interrupt
handlers.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">reg</td>
<td valign="top"> Register number (0,2,4,... for Word access)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top">
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20fast_read_config_word">Binding</a> &nbsp; <a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#fast_read_config_byte">fast_read_config_byte</a> &nbsp;
<a href="#read_config_word">read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a> &nbsp; <a href="#fast_read_config_longword">fast_read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20fast_read_config_word">4.16.3.1 Bindings for fast_read_config_word</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#fast_read_config_word">fast_read_config_word</a> (int32_t handle, uint8_t reg);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #306,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #8,sp         ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="find_pci_classcode">4.16.4 find_pci_classcode</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »find_pci_classcode« - Returns a device handle for a device
that matches the given class code.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 301
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t find_pci_classcode( int32_t classcode, int16_t index );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This functions returns a device handle for a device that
matches the given class code.
<br>&nbsp;
<br>A driver can query multiple devices with the same class code by
starting with index = 0,1,2,... and calling this function until
<a href="PCI_BIOS.html#PCI_DEVICE_NOT_FOUND">PCI_DEVICE_NOT_FOUND</a> is returned.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">classcode</td>
<td valign="top"> class code in bits 23..0
<br>
<br>&nbsp;
<br>Bit 23 ..16 Base class (0 - $FF)
<br>Bit 15 .. 8 Sub class (0 - $FF)
<br>Bit 7 .. 0 Programming Interface (0 - $FF)
<br>&nbsp;
<br>Mask in bits 26..24
<br>Bit 26: (0: compare base class, 1: ignore it)
<br>Bit 25: (0: compare sub class, 1: ignore it)
<br>Bit 24: (0: compare Progr. Interface, 1: ignore it)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">index</td>
<td valign="top"> index of card (0 - number of cards with these IDs)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Device handle for a device or <a href="PCI_BIOS.html#PCI_DEVICE_NOT_FOUND">PCI_DEVICE_NOT_FOUND</a>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20find_pci_classcode">Binding</a> &nbsp; <a href="#find_pci_device">find_pci_device</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20find_pci_classcode">4.16.4.1 Bindings for find_pci_classcode</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#find_pci_classcode">find_pci_classcode</a>( int32_t classcode, int16_t index );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    index,-(sp)       ; Offset 6
move.l    classcode,-(sp)   ; Offset 2
move.w    #301,-(sp)        ; Offset 0
trap      #14               ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #8,sp             ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="find_pci_device">4.16.5 find_pci_device</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »find_pci_device« - Returns a device handle for a device that
matches the given device and vendor ID.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 300
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t find_pci_device( int32_t id, int16_t index);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This functions returns a device handle for a device that
matches the given device and vendor ID. A driver can query multiple
devices with the same device and vendor ID by starting with index =
0,1,2,... and calling this function until <a href="PCI_BIOS.html#PCI_DEVICE_NOT_FOUND">PCI_DEVICE_NOT_FOUND</a> is
returned.
<br>&nbsp;
<br>As a special case, Vendor ID $FFFF can be used to query all
cards found in the system, the specified Device ID is ignored in that
case.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">id</td>
<td valign="top"> Device ID in bits 31..16 (0 - $FFFF)
<br>Vendor ID in bits 15..0 (0 - $FFFE)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">index</td>
<td valign="top"> <a href="indexudo.html">Index</a> of card (0 - number of cards with these IDs)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Device handle for a device or <a href="PCI_BIOS.html#PCI_DEVICE_NOT_FOUND">PCI_DEVICE_NOT_FOUND</a>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20find_pci_device">Binding</a> &nbsp; <a href="#find_pci_classcode">find_pci_classcode</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20find_pci_device">4.16.5.1 Bindings for find_pci_device</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#find_pci_device">find_pci_device</a>( int32_t id, int16_t index);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    index,-(sp)  ; Offset 6
move.l    id,-(sp)     ; Offset 2
move.w    #300,-(sp)   ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #8,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="get_machine_id">4.16.6 get_machine_id</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Get Machine ID«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 337
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t get_machine_id ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function can be used to get a unique machine ID for the
computer the driver is running on.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Machine ID, or 0 (no ID available), <a href="#PCI-BIOS">PCI-BIOS</a> error-codes
<br>&nbsp;
<br>Positive, non-zero values are machine IDs. They contain a
manufacturer code in bit 24..31 and a unique serial number which is
set by the manufacturer during production in bit 0..23.
<br>&nbsp;
<br>The following manufacturer codes are defined:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">0</td>
  <td align="left" valign="top">Medusa/Hades</td>
</tr>
<tr>
  <td align="left" valign="top">1</td>
  <td align="left" valign="top">Milan</td>
</tr>
<tr>
  <td align="left" valign="top">2</td>
  <td align="left" valign="top">PAK/Panther 2</td>
</tr>
<tr>
  <td align="left" valign="top">3</td>
  <td align="left" valign="top">ARAnyM</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20get_machine_id">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20get_machine_id">4.16.6.1 Bindings for get_machine_id</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#get_machine_id">get_machine_id</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #337,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #2,sp         ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="get_resource">4.16.7 get_resource</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Get Resource Data«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 316
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t get_resource ( int32_t handle );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Device handle
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Pointer to array of resource descriptors or <a href="#PCI-BIOS">PCI-BIOS</a>
error-codes.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20get_resource">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20get_resource">4.16.7.1 Bindings for get_resource</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#get_resource">get_resource</a> ( int32_t handle );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    handle,-(sp)  ; Offset 2
move.w    #316,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #6,sp         ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="get_routing">4.16.8 get_routing</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Get Interrupt Routing Options«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 314
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t get_routing ( int32_t handle );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> To be defined. Not for use by device drivers.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a> error-codes
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20get_routing">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20get_routing">4.16.8.1 Bindings for get_routing</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#get_routing">get_routing</a> ( int32_t handle );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    handle,-(sp)    ; Offset 2
move.w    #314,-(sp)      ; Offset 0
trap      #14             ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #6,sp           ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="hook_interrupt">4.16.9 hook_interrupt</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Hook Interrupt Vector«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 311
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t hook_interrupt (int32_t handle, uint32_t *routine,
uint32_t *parameter);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function hooks the driver into the interrupt chain to
which a specific interrupt on the given card is routed. The interrupt
is enabled on the system level, however, it is the drivers
responsibility to enable the interrupt on the card as needed.
<br>&nbsp;
<br>The driver should first hook into the interrupt chain, and then
enable the interrupt on the card, in order not to cause spurious
interrupts.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">routine</td>
<td valign="top"> Pointer to interrupt handler
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">parameter</td>
<td valign="top"> Parameter for interrupt handler
<br>&nbsp;
<br>The parameter is passed to the interrupt handler unmodified -
its meaning is totally driver dependent.
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20hook_interrupt">Binding</a> &nbsp; <a href="#unhook_interrupt">unhook_interrupt</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20hook_interrupt">4.16.9.1 Bindings for hook_interrupt</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#hook_interrupt">hook_interrupt</a> (int32_t handle, uint32_t *routine,
uint32_t *parameter);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    parameter,-(sp) ; Offset 10
move.l    routine,-(sp)   ; Offset 6
move.l    handle,-(sp)    ; Offset 2
move.w    #311,-(sp)      ; Offset 0
trap      #14             ; Call <a href="xbios_main.html">XBIOS</a>
lea       14(sp),sp       ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="read_config_byte">4.16.10 read_config_byte</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read configuration byte«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 302
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t read_config_byte (int32_t handle, uint8_t reg, uint8_t
*address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function read data from the PCI configuration space of a
given card.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>reg</i></td>
<td valign="top"> Register number (0,1,2,... for Byte access)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>address</i></td>
<td valign="top"> Pointer to space for read data
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20read_config_byte">Binding</a> &nbsp; <a href="#fast_read_config_byte">fast_read_config_byte</a> &nbsp; <a href="#read_config_word">read_config_word</a> &nbsp;
<a href="#fast_read_config_word">fast_read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a> &nbsp;
<a href="#fast_read_config_longword">fast_read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20read_config_byte">4.16.10.1 Bindings for read_config_byte</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#fast_read_config_byte">fast_read_config_byte</a> (int32_t handle, uint8_t reg,
uint8_t *address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       address       ; Offset 8
move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #302,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       12(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="read_config_longword">4.16.11 read_config_longword</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read configuration longword«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 304
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t read_config_longword (int32_t handle, uint8_t reg,
uint32_t *address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function read data from the PCI configuration space of a
given card.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>reg</i></td>
<td valign="top"> Register number (0,4,8,... for Longword access)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>address</i></td>
<td valign="top"> Pointer to space for read data
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20read_config_longword">Binding</a> &nbsp; <a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#fast_read_config_byte">fast_read_config_byte</a> &nbsp;
<a href="#read_config_word">read_config_word</a> &nbsp; <a href="#fast_read_config_word">fast_read_config_word</a> &nbsp; <a href="#fast_read_config_longword">fast_read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20read_config_longword">4.16.11.1 Bindings for read_config_longword</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#read_config_longword">read_config_longword</a> (int32_t handle, uint8_t reg,
uint32_t *address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       address       ; Offset 8
move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #304,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       12(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="read_config_word">4.16.12 read_config_word</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read configuration word«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 303
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t read_config_word (int32_t handle, uint8_t reg, uint16_t
*address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function read data from the PCI configuration space of a
given card.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle of the selected PCI device
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>reg</i></td>
<td valign="top"> Address of the configuration register
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>address</i></td>
<td valign="top"> Pointer to space for read data
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20read_config_word">Binding</a> &nbsp; <a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#fast_read_config_byte">fast_read_config_byte</a> &nbsp;
<a href="#fast_read_config_word">fast_read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a> &nbsp;
<a href="#fast_read_config_longword">fast_read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20read_config_word">4.16.12.1 Bindings for read_config_word</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#read_config_word">read_config_word</a> (int32_t handle, uint8_t reg, uint16_t
*address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       address       ; Offset 8
move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #303,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       12(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="set_interrupt">4.16.13 set_interrupt</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Set Hardware Interrupt«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 315
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t set_interrupt ( int32_t handle );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> To be defined. Not for use by device drivers.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20set_interrupt">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20set_interrupt">4.16.13.1 Bindings for set_interrupt</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#set_interrupt">set_interrupt</a> ( int32_t handle );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    handle,-(sp)    ; Offset 2
move.w    #315,-(sp)      ; Offset 0
trap      #14             ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #6,sp           ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="special_cycle">4.16.14 special_cycle</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Generates special cycle«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 313
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t special_cycle ( unit8_t bus, uint32_t data );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function generates a special cycle on the PCI bus.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Bus number
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">data</td>
<td valign="top"> Cspecial cycle data
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20special_cycle">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20special_cycle">4.16.14.1 Bindings for special_cycle</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#special_cycle">special_cycle</a> ( unit8_t bus, uint32_t data );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    data,-(sp)    ; Offset 4
move.w    bus,-(sp)     ; Offset 2
move.w    #313,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #8,sp         ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="unhook_interrupt">4.16.15 unhook_interrupt</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> » «
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 312
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t unhook_interrupt (int32_t handle);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function removes the driver from the interrupt chain to
which a specific interrupt on the given card is routed. The driver
must turn off interrupt generation on the card before calling this
function.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Device handle
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20unhook_interrupt">Binding</a> &nbsp; <a href="#hook_interrupt">hook_interrupt</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20unhook_interrupt">4.16.15.1 Bindings for unhook_interrupt</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#unhook_interrupt">unhook_interrupt</a> (int32_t handle);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    handle,-(sp)  ; Offset 2
move.w    #312,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #6,sp         ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="write_config_byte">4.16.16 write_config_byte</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Write configuration byte«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 308
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t write_config_byte (int32_t handle, uint8_t reg, uint8_t
val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function writes data to the PCI configuration space of a
given card.
<br>&nbsp;
<br>The data is in little endian format, as described in the PCI
specification.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>reg</i></td>
<td valign="top"> Register number (0,1,2,... for byte access)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>val</i></td>
<td valign="top"> Data to write (8 bits)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top">
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20write_config_byte">Binding</a> &nbsp; <a href="#write_config_word">write_config_word</a> &nbsp; <a href="#write_config_longword">write_config_longword</a> &nbsp;
<a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#read_config_word">read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20write_config_byte">4.16.16.1 Bindings for write_config_byte</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#write_config_byte">write_config_byte</a> (int32_t handle, uint8_t reg, uint8_t
val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    val,-(sp)     ; Offset 8
move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #308,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       10(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="write_config_longword">4.16.17 write_config_longword</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Write configuration longword«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 310
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t write_config_longword (int32_t handle, uint8_t reg,
uint32_t val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function writes data to the PCI configuration space of a
given card.
<br>&nbsp;
<br>The data is in little endian format, as described in the PCI
specification.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>reg</i></td>
<td valign="top"> Register number (0,4,8,... for Longword access)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>val</i></td>
<td valign="top"> Data to write (32 bits)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top">
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20write_config_longword">Binding</a> &nbsp; <a href="#write_config_byte">write_config_byte</a> &nbsp; <a href="#write_config_word">write_config_word</a> &nbsp;
<a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#read_config_word">read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20write_config_longword">4.16.17.1 Bindings for write_config_longword</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#write_config_longword">write_config_longword</a> (int32_t handle, uint8_t reg,
uint32_t val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    val,-(sp)     ; Offset 8
move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #310,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       12(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="write_config_word">4.16.18 write_config_word</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Write configuration word«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 309
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t write_config_word (int32_t handle, uint8_t reg,
uint16_t val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function writes data to the PCI configuration space of a
given card.
<br>&nbsp;
<br>The data is in little endian format, as described in the PCI
specification.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>reg</i></td>
<td valign="top"> Register number (0,2,4,... for Word access)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>val</i></td>
<td valign="top"> Data to write (16 bits)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top">
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20write_config_word">Binding</a> &nbsp; <a href="#write_config_byte">write_config_byte</a> &nbsp; <a href="#write_config_longword">write_config_longword</a> &nbsp;
<a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#read_config_word">read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20write_config_word">4.16.18.1 Bindings for write_config_word</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#write_config_word">write_config_word</a> (int32_t handle, uint8_t reg, uint16_t
val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    val,-(sp)     ; Offset 8
move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #309,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       10(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="PCI-BIOS_20Error_20codes">4.16.19 PCI-BIOS Error codes</a></h3>
<p>The following error codes can be returned by the PCI <a href="bios_main.html">BIOS</a>
functions:
</p>
<a name="PCI_SUCCESSFUL"></a>
<a name="PCI_FUNC_NOT_SUPPORTED"></a>
<a name="PCI_BAD_VENDOR_ID"></a>
<a name="PCI_DEVICE_NOT_FOUND"></a>
<a name="PCI_BAD_REGISTER_NUMBER"></a>
<a name="PCI_SET_FAILED"></a>
<a name="PCI_BUFFER_TOO_SMALL"></a>
<a name="PCI_GENERAL_ERROR"></a>
<a name="PCI_BAD_HANDLE"></a>
<div align="left"><table border="1" frame="box" class="UDO_env_table">
<tr>
  <td align="left" valign="top">0x00000000</td>
  <td align="left" valign="top">PCI_SUCCESSFUL</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFFE</td>
  <td align="left" valign="top">PCI_FUNC_NOT_SUPPORTED</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFFD</td>
  <td align="left" valign="top">PCI_BAD_VENDOR_ID</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFFC</td>
  <td align="left" valign="top">PCI_DEVICE_NOT_FOUND</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFFB</td>
  <td align="left" valign="top">PCI_BAD_REGISTER_NUMBER</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFFA</td>
  <td align="left" valign="top">PCI_SET_FAILED</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFF9</td>
  <td align="left" valign="top">PCI_BUFFER_TOO_SMALL</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFF8</td>
  <td align="left" valign="top">PCI_GENERAL_ERROR</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFF7</td>
  <td align="left" valign="top">PCI_BAD_HANDLE</td>
</tr>
</table>
</div>

<p>The following error codes are not returned by PCI <a href="bios_main.html">BIOS</a> functions
directly, but are reserved for use by a library which uses these
routines.
</p>
<a name="PCI_BIOS_NOT_INSTALLED"></a>
<a name="PCI_BIOS_WRONG_VERSION"></a>
<div align="left"><table border="1" frame="box" class="UDO_env_table">
<tr>
  <td align="left" valign="top">0xFFFFF001</td>
  <td align="left" valign="top">PCI_BIOS_NOT_INSTALLED</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFF000</td>
  <td align="left" valign="top">PCI_BIOS_WRONG_VERSION</td>
</tr>
</table>
</div>

<hr>

<a name="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_FOOT" href="xbios_main.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24">XBIOS</a>
<a name="UDO_nav_lf_FOOT" href="xbios_overscan.html"><img src="udo_lf.gif" alt="OverScan XBIOS extension" title="OverScan XBIOS extension" border="0" width="24" height="24">OverScan XBIOS extension</a>
<a name="UDO_nav_rg_FOOT" href="xbios_interface.html"><img src="udo_rg.gif" alt="Interface programming" title="Interface programming" border="0" width="24" height="24">Interface programming</a>
</body>
</html>
